(ns mister-rogers.neighborhood-search
  (:refer-clojure :exclude [cond])
  (:require [better-cond.core :refer [cond defnc]]
            [medley.core :as medley]
            [com.rpl.specter :as specter
             :refer [ALL NONE ATOM keypath select-any transform setval]]
            [taoensso.timbre :as timbre
             :refer [log  trace  debug  info  warn  error  fatal  report
                     logf tracef debugf infof warnf errorf fatalf reportf
                     spy get-env]]
            [mister-rogers.search :as search]
            [mister-rogers.protocols :as mrp]
            [mister-rogers.problem :as prob]))

(defrecord NeighborhoodSearch ;; extends LocalSearch with neighborhood
    [search neighborhood a-num-accepted-moves a-num-rejected-moves cache]
  mrp/Search
  (init [this] (mrp/init search)
    (reset! a-num-accepted-moves 0)
    (reset! a-num-rejected-moes 0))
  (start [this] (mrp/start search))
  (stop [this] (mrp/stop search))
  (search-started [this] (mrp/search-started search))
  (search-stopped [this] (mrp/search-stopped search))
  Runnable
  (run [this] (start this))
  Object
  (toString [this] (search/label search)))

(defnc neighborhood-search
  "Takes a map with required key :problem and :neighborhood
and optional keys :name, :search-listeners, :stop-criterion-checker.
Creates a search that uses moves generated by neighborhood to
explore out from a randomly-generated solution, to optimize."
  [init-map]
  (nil? (:problem init-map)) 
  (throw (ex-info ":problem is a required key for init-map in search"))
  (nil? (:neighborhood init-map))
  (throw (ex-info ":neighborhood is a required key for init-map in search"))
  :let [init-map (merge {:name "NeighborhoodSearch"} init-map),
        search (search/local-search init-map)]
  (NeighborhoodSearch. search (:neighborhood init-map)
                       (atom 0) (atom 0) (single-evaluated-move-cache)))









