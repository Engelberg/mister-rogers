(ns mister-rogers.strategies
  (:refer-clojure :exclude [cond])
  (:require [better-cond.core :refer [cond defnc]]
            [medley.core :as medley]
            [com.rpl.specter :as specter
             :refer [ALL NONE ATOM keypath select-any transform setval]]
            [taoensso.timbre :as timbre
             :refer [log  trace  debug  info  warn  error  fatal  report
                     logf tracef debugf infof warnf errorf fatalf reportf
                     spy get-env]]
            [mister-rogers.search :as search]
            [mister-rogers.protocols :as mrp]
            [mister-rogers.problem :as prob])
  (:import mister_rogers.search.Search
           mister_rogers.search.SEV))

(defnc get-current-solution [^Search search]
  :let [^SEV current @(.-a-current search)]
  (.-solution current))
  
(def random-descent-strategy
  (reify
    mrp/SearchStrategy
    (search-step [strategy search]
      (cond
        :let [neighborhood (.-neighborhood ^Search search),
              move (mrp/random-move neighborhood (get-current-solution search))]
        (nil? move) (search/stop search)
        (search/improvement-move? search move) (search/accept-move search move)
        :else (search/reject-move search move)))))

(defnc random-descent
  "Takes a map with required key :problem and :neighborhood
and optional keys :name, :search-listeners, :stop-criterion-checker.
Creates a search that uses moves generated by a neighborhood to
explore out from a randomly-generated solution, to optimize."
  [init-map]
  (search/neighborhood-search
   (merge {:name "RandomDescentSearch",
           :strategy random-descent-strategy}
          init-map)))


